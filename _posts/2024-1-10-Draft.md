---
layout: post
title: Draft
---
## First off, what is a Command, and Control program?

A C2, consists of two programs: A client application that communicates with the server, and a server program that handles the active connections, and allows us to send commands, and action requests to the client device. Generally speaking the three chief priorities of a C2, are to persist, remain undetected, and offer the C2 admin, easy access and control of the client device. 


## A Brief Look At The Remote Admin Server

In late august, I decided to finally take on my first project. The initial scope was simply to simply achieve a TCP connection between two machines. Gradually with time, the scope expanded until now where the end goal is remote command execution, schedulable jobs, and a queryable logging database. At the moment the capabilities are sending commands over TCP for the client program to interpret, and execute. In addition to a very basic logging system. 

The logic flow of Remote Admin in its current form is fully oriented around a loop: Querying the WinAPI for any inbound TCP connections on the servers port,  followed by the iteration of a object vector. These struct objects are the heart of Remote Admins functionality, each being representative of a single client. Including a variety of members, to enable the reliable, albiet limited range of functionality. 

```bash
struct clientSocketInformation
{
	std::string alias; //Allows for name support
	FD_SET socketOfClientAsSet; //FD_SET with only this socket. the FD_ functions from Winsock2, support only FD_SET, and not individual SOCKET
	SOCKET socketOfClient{};
	bool isReadable(FD_SET);
	bool isDisconnected(FD_SET, bool, int);
	void closeConnection(SOCKET&);
	std::vector<messageInformation> messages; //Logs messages with this client
	void log(clientSocketInformation& socketForKey, char serverSendingMsg[4096]);
	void logSent(clientSocketInformation, char storeThis[4096]);
	
	//Constructor
	clientSocketInformation(SOCKET socketOfClientInput)
	{
		FD_ZERO(&socketOfClientAsSet); //clear fd_set which will hold a single socket 
		socketOfClient = socketOfClientInput;
		FD_SET(socketOfClientInput, &socketOfClientAsSet);
	}
	clientSocketInformation()
	{
	}
};
```


After you emotionally process the distress of seeing my memory unsafe usage of C-style buffers, I would like to quickly mention that the struct, is going to be replaced by a class, incorporating the many lessons learned, so far. 



## Why Write a C2? That sounds way too complicated!

Writing a Command, and Control system requires constant tinkering with sockets which generally will really force you to get comfortable with Windows programming conceptually, The abundance of stack overflow discussions will make sure you do not you drown in the sometimes esoteric Microsoft documentation. It cannot be understated how much more approachable the project is because of those secondary reference sources. I hadn’t fully appreciate this luxury of the Winsock2 library, until recently when I found myself nearly pulling my hair out while working with the Kernel-Mode Driver Framework, on a few projects. My only potential for reprieve was the occasional semi-relevant 20-year-old post on the OSR community forum!

> “Anxiety is the dizziness of freedom.” (Freedom courtesy of the Windows API)
> - Soren Kierkegaard


It is normal to be feel absolutely lost in a sea of jargon when starting a project. Topics like raw sockets, endianness, winsock2, Berkeley sockets can be overwhelming. Thats where I was, and thankfully the free, [Beej's Guide to Network Programming](https://beej.us/guide/bgnet/) saved my life. It not only explains all the vital background theory, of sockets but also gives you a strong footing with Winsock2 itself.

Also If you're someone who is comfortable occasionally leaning on generative AI to explain or troubleshoot code, you'll be happy to know that the predominant LLMs are quite well-trained on Winsock2, and many adjacent WinAPI functions. So, worst-case scenario, you'll never truly be left high and dry.  With enough time the windows programming hurdles will become smaller, and smaller allowing you gradually focus less on troubleshooting windows functionalities, and more on realizing your vision.



### Creative flexibility of C2 development, with the WinAPI.


Once you've eventually established basic data transmission over TCP, the program is your oyster! Do you want to focus on designing a professional GUI? Or perhaps you’d prefer to enhance the program's security, ensuring excellent handling of client transmissions and building a multi-admin system for collaborative use by security professionals. Alternatively, you might find more enjoyment in introducing polymorphic features, such as a custom communication stack utilizing raw sockets. This can give you the granular control to (hopefully) communicate with a client without lighting up the SIEM like a Christmas tree. With the WinAPI at your side, as a friend or foe. You have such a wide range of functionalities at your disposal, you can implement almost any functionality your mind can conceive...Although taking off the rose coloured glasses, the WinAPI syntax, naming practices, and amount of parameters may "borrow" some of your sanity.


![[sbqn85h6p6y11.jpg]]
Oh, one could only dream.
  

#### Reflection, on the development process. 

Ive been fortunate to experience the misfortunes of developing `Remote Admin`, with the WinAPI, every large change made to the codebase represents a few sleepless nights with an ever-furrowed brow. followed by a few days of deep satisfaction, and inevitable repeat of that cycle! The first growing pain was an early September change to the handling of clients. Initially I had a simple array that would hold any socket file descriptors(Those descriptors, are a handle like representation of the connection). However I wanted the program to support size changing of the array during runtime. This would not be possible with a C style array, as arrays exist on the stack, so I opted for the heap container `std::vector` . That was followed by working OOP into my code using a struct type to hold the socket file descriptor, alongside other data relating to each.  The proceeding 3 months of other growing pains introduced me to topics like multithreading, memory safety, basic design patterns and taught me much about the non-technical aspects of project design. Now I am working to replace the struct, and the litany of direct member accesses, with a class. Im looking forward to work with privatized class members, and push myself into learning to write a proper interface. 

```
quote about a good interface not requiring any method implementation understanding for its proper use
```

My next extension to the server program will be to integrate MySQL into the server program, for communication logging is not only from a desire to expand on the programs capability, it is also in efforts to build T-shaped knowledge, In case your not familiar with the concept of the T-shaped knowledge, its an approach to  that prioritizes a strong, and wide base of general, understanding, alongside deep specialization, into a particular domain. Hiring preferences, in tech have made it clear that we should prioritize learning like a T-shaped engineer, but what would that engineer do? Well, I don't actually know. However, if its true that *"every painter paints themselves"* we know that the T-shaped engineer must write T-shaped programs. This is why a C2 is an excellent project, its necessarily commands a progression of understanding in the topic of socket programming, but soon you'll feel the temptation to integration multithreading, new features, encryption, GUI, database integration, or even file transferring capabilities. After sitting with thing you know its 4AM, and your planned a very diverse development roadmap that will occupy the next three weeks. 


It would do us well to remember that at the end of the day, it’s not all about the code itself—it’s about the process. A process that forces you to stretch, stumble (probably fall a few times), and yet emerge as a better developer. So go ahead, write that C2. And when you’re done, take a step back, admire the work you’ve put in... and then immediately spot the design flaws you hadn’t noticed before. The most vital lesson a large project teaches, in my opinion, is how to be comfortable tackling a grand idea while learning most of what you need along the way. It’s about writing code, uncovering hidden subset problems, and solving them one by one. Although the process to create something meaningful is messy, chaotic, and confusing...

> “In Filth It will be Found” -Carl Gustav Jung

Each obstacle you overcome not only strengthens your technical skills but also grows your capacity as a problem solver.